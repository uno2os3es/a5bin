#!/data/data/com.termux/files/usr/bin/env python3

import csv
import logging
import os
import shutil
import subprocess
import sys
from multiprocessing import Manager, Pool, cpu_count
from pathlib import Path

# --- Configuration ---
TMP_BASE = Path.home() / 'tmp'
REPACK_DIR = TMP_BASE / 'repack'
WHL_DIR = TMP_BASE / 'whl'
LOG_FILE = TMP_BASE / 'repack-errors.log'


def setup_logging() -> None:
    """Configures error logging to file."""
    if not TMP_BASE.exists():
        TMP_BASE.mkdir(parents=True)

    logging.basicConfig(
        filename=LOG_FILE,
        level=logging.ERROR,
        format='%(asctime)s - %(levelname)s - %(message)s',
        filemode='w',
    )


def get_dist_info_dirs():
    """Finds all .dist-info directories in the current location."""
    return [
        d for d in Path('.').iterdir()
        if d.is_dir() and d.name.endswith('.dist-info')
    ]


def resolve_sys_path(file_path_str, pkg_root_name):
    """Heuristic to map files outside site-packages (starting with ..)
    to the correct wheel .data directory structure.

    Returns: (destination_relative_path, is_valid)
    """
    path = Path(file_path_str)
    parts = path.parts

    # Handle relative paths escaping site-packages (e.g., ../../bin/script)
    if parts[0] == '..':
        # Determine the type of data based on standard python paths
        # Common relative paths from site-packages:
        # ../../bin -> scripts
        # ../../Scripts -> scripts (Windows)
        # ../../include -> headers
        # ../../share -> data

        data_dir = f'{pkg_root_name}.data'

        # Normalize parts to remove '..'
        clean_parts = [p for p in parts if p != '..']

        if not clean_parts:
            return None, False

        top_folder = clean_parts[0].lower()

        if top_folder in ['bin', 'scripts']:
            # Map to pkg.data/scripts/filename
            return Path(data_dir) / 'scripts' / Path(*clean_parts[1:]), True
        elif top_folder == 'include':
            return Path(data_dir) / 'headers' / Path(*clean_parts[1:]), True
        elif top_folder == 'share':
            return Path(data_dir) / 'data' / Path(*clean_parts[1:]), True
        else:
            # Fallback: put in data/pure_name
            return Path(data_dir) / 'data' / Path(*clean_parts), True

    # Standard file inside site-packages
    return path, True


def get_unique_filename(directory, filename):
    """Returns a unique filename if the target already exists.
    Ex: package.whl -> package_1.whl.
    """
    target = directory / filename
    if not target.exists():
        return target

    name_stem = target.stem
    suffix = target.suffix
    counter = 1

    while True:
        new_name = f'{name_stem}_{counter}{suffix}'
        new_target = directory / new_name
        if not new_target.exists():
            return new_target
        counter += 1


def process_package(args) -> bool | None:
    """Worker function to repack a single package."""
    dist_path_str, progress_queue = args
    dist_path = Path(dist_path_str)

    try:
        # 1. Setup directories
        pkg_dname = dist_path.name
        # Infer package name and version for the .data dir convention (Name-Version.dist-info)
        # We strip .dist-info to get the Name-Version base
        pkg_base_name = pkg_dname.replace('.dist-info', '')

        temp_pkg_root = REPACK_DIR / pkg_base_name

        if temp_pkg_root.exists():
            shutil.rmtree(temp_pkg_root)
        temp_pkg_root.mkdir(parents=True)

        record_file = dist_path / 'RECORD'

        if not record_file.exists():
            raise FileNotFoundError(f'RECORD file missing for {pkg_dname}')

        # 2. Copy files listed in RECORD
        with open(record_file, encoding='utf-8', errors='ignore') as rf:
            reader = csv.reader(rf)
            for row in reader:
                if not row:
                    continue

                rel_path_str = row[0]

                # The RECORD file is technically relative to the wheel root (site-packages here)
                source_file = Path(rel_path_str)

                # Don't crash if source missing (requested requirement)
                if not source_file.exists():
                    continue

                # Calculate destination path
                dest_rel_path, valid = resolve_sys_path(rel_path_str,
                                                        pkg_base_name)
                if not valid:
                    continue

                dest_file = temp_pkg_root / dest_rel_path

                dest_file.parent.mkdir(parents=True, exist_ok=True)
                shutil.copy2(source_file, dest_file)

        # 3. Explicitly copy the .dist-info directory
        # (RECORD usually contains files *inside* dist-info, but we ensure the dir exists)
        temp_pkg_root / pkg_dname
        # We might have already copied files into it via RECORD loop, but let's ensure
        # the directory structure is clean.
        # Note: wheel pack requires the .dist-info folder to be present.

        # 4. Run wheel pack
        # We use a temporary build dir for the wheel output to capture the name
        temp_build_dir = temp_pkg_root / 'build_whl'
        temp_build_dir.mkdir()

        # Suppress output
        cmd = [
            sys.executable,
            '-m',
            'wheel',
            'pack',
            str(temp_pkg_root),
            '--dest-dir',
            str(temp_build_dir),
        ]
        result = subprocess.run(cmd, capture_output=True, text=True)

        if result.returncode != 0:
            raise RuntimeError(f'Wheel pack failed: {result.stderr}')

        # 5. Move and Rename
        generated_whl = next(temp_build_dir.glob('*.whl'), None)
        if generated_whl:
            final_target = get_unique_filename(WHL_DIR, generated_whl.name)
            shutil.copy2(str(generated_whl), str(final_target))
        else:
            raise FileNotFoundError(
                f'Wheel pack ran but produced no .whl for {pkg_dname}')

        # Cleanup
        #        shutil.rmtree(temp_pkg_root)

        progress_queue.put(1)  # Signal completion
        return True

    except Exception as e:
        logging.error(f'Failed to repack {dist_path.name}: {str(e)}')
        progress_queue.put(1)  # Signal completion even on error
        return False


def main() -> None:
    # Check environment
    if Path('site-packages') not in Path.cwd().parents and Path.cwd(
    ).name != 'site-packages':
        print(
            'Warning: Current directory does not look like a site-packages folder.'
        )
        print(f'CWD: {os.getcwd()}')
        # Proceeding anyway as requested "assume we are in..."

    setup_logging()

    # Create output dirs
    if not WHL_DIR.exists():
        WHL_DIR.mkdir(parents=True)

    dist_infos = get_dist_info_dirs()
    total_pkgs = len(dist_infos)

    if total_pkgs == 0:
        print('No .dist-info directories found.')
        return

    print(f'Found {total_pkgs} packages. Starting repack...')
    print(f'Logs: {LOG_FILE}')
    print(f'Output: {WHL_DIR}')

    # Manager for queue
    m = Manager()
    q = m.Queue()

    # Prepare args
    # We convert Path to str for pickling safety across some OS/MP contexts
    tasks = [(str(p), q) for p in dist_infos]

    with Pool(processes=cpu_count()) as pool:
        # Start workers
        result_async = pool.map_async(process_package, tasks)

        # Monitor progress
        processed_count = 0
        while not result_async.ready():
            # Drain queue to update count
            while not q.empty():
                q.get()
                processed_count += 1

            percent = (processed_count / total_pkgs) * 100
            sys.stdout.write(
                f'\rCompleted: {percent:.1f}% ({processed_count}/{total_pkgs})')
            sys.stdout.flush()
            time.sleep(0.1)

        # Final update
        while not q.empty():
            q.get()
            processed_count += 1
        sys.stdout.write(f'\rCompleted: 100.0% ({total_pkgs}/{total_pkgs})\n')


if __name__ == '__main__':
    # Ensure wheel is installed
    try:
        import wheel
    except ImportError:
        print(
            "Error: 'wheel' package is not installed. Please run: pip install wheel"
        )
        sys.exit(1)

    # Ensure multiprocessing works safely on Windows/macOS
    import time

    main()
